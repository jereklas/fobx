<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="description" content="# Shallow Observables in FobX"/><meta property="og:title" content="Shallow Observables in FobX"/><meta property="og:description" content="# Shallow Observables in FobX"/><meta property="og:type" content="website"/><meta property="og:url" content="/fobx/core-docs-shallow-observables"/><title>Shallow Observables in FobX | FobX Documentation</title><link rel="stylesheet" href="/fobx/assets/styles.css"/><script type="module" src="/fobx/scripts/chunks/shared.js"></script><script type="module" src="/fobx/scripts/core-docs-shallow-observables.js"></script></head><body><div id="root"><div class="docs-layout"><header class="docs-header"><nav class="docs-nav"><a href="/fobx" class="docs-logo">FobX Documentation</a><ul class="docs-nav-links"><li><a href="/fobx/" class="docs-nav-link">Documentation</a></li><li><a href="https://github.com/jereklas/fobx" target="_blank" rel="noopener noreferrer" class="docs-nav-link">GitHub</a></li></ul><div class="docs-search"><input type="search" placeholder="Search docs..." aria-label="Search documentation" class="docs-search-input"/></div></nav></header><aside class="docs-sidebar"><div class="sidebar-section"><h3 class="sidebar-title">Core</h3><nav><ul class="sidebar-nav"><li><a href="/fobx/core-docs-controlling-comparisons" class="sidebar-link ">Controlling Comparisons in FobX</a></li><li><a href="/fobx/core-docs-creating-observable-state" class="sidebar-link ">Creating Observable State in FobX</a></li><li><a href="/fobx/core-docs-shallow-observables" class="sidebar-link active">Shallow Observables in FobX</a></li></ul></nav></div></aside><main class="docs-main"><div class="docs-content"><article class="docs-content"><div class="content"><div><span><h1 id="shallow-observables-in-fobx"><span>Shallow Observables in FobX</span></h1><div class="reading-time">4 min read</div></span><span><p><span>This document explains the different approaches to shallow observables in FobX:</span></p></span><span><ol><span><li><span>Using </span><span><code>observable({}, {}, { shallowRef: true })</code></span></li></span><span><li><span>Using </span><span><code>observable({}, { prop: &quot;observable.shallow&quot; })</code></span><span> or</span><span> </span><span><code>makeObservable({}, { prop: &quot;observable.shallow&quot; })</code></span></li></span><span><li><span>Using </span><span><code>observable({}, { prop: &quot;observable.ref&quot; })</code></span><span> or</span><span> </span><span><code>makeObservable({}, { prop: &quot;observable.ref&quot; })</code></span></li></span></ol></span><span><blockquote><span><p><span><div><span>Note</span></div></span><span>: The </span><span><code>shallow: true</code></span><span> option has been deprecated and will be removed</span><span> </span><span>in a future version. Please use </span><span><code>shallowRef: true</code></span><span> instead, which provides the</span><span> </span><span>same functionality.</span></p></span></blockquote></span><span><h2 id="the-three-implementations"><span>The Three Implementations</span></h2></span><span><h3 id="_1-using-observable-with-shallowref-true-option"><span>1. Using </span><span><code>observable()</code></span><span> with </span><span><code>{ shallowRef: true }</code></span><span> option</span></h3></span><span><pre class="language-ts"><code>const obj = observable(someObject, {}, { shallowRef: true })

// Deprecated - don't use:
// const obj = observable(someObject, {}, { shallow: true })
</code></pre></span><span><p><span>This implementation keeps the original references for all properties of the</span><span> </span><span>object. It makes the properties observable (so changes to the properties</span><span> </span><span>themselves will be tracked), but the properties' values maintain their original</span><span> </span><span>non-observable references.</span></p></span><span><p><span>For collections (Arrays, Maps, Sets), this means:</span></p></span><span><ul><span><li><span>The collection itself is stored in an observable box</span></li></span><span><li><span>The collection is NOT converted to an</span><span> </span><span>ObservableArray/ObservableMap/ObservableSet</span></li></span><span><li><span>Changes to the collection (adding/removing items) will NOT trigger reactions</span></li></span><span><li><span>Only replacing the entire collection will trigger reactions</span></li></span></ul></span><span><h3 id="_2-using-observableshallow-annotation"><span>2. Using </span><span><code>observable.shallow</code></span><span> annotation</span></h3></span><span><pre class="language-ts"><code>// With observable()
observable(obj, { prop: &quot;observable.shallow&quot; })

// Or with makeObservable()
makeObservable(obj, { prop: &quot;observable.shallow&quot; })
</code></pre></span><span><p><span>This implementation:</span></p></span><span><ul><span><li><span>Makes the property observable</span></li></span><span><li><span>If the property is a collection (Array, Map, Set), it turns it into an</span><span> </span><span>ObservableArray/ObservableMap/ObservableSet with </span><span><code>{ shallow: true }</code></span></li></span><span><li><span>Changes to the collection (adding/removing items) WILL trigger reactions</span></li></span><span><li><span>The items inside the collection maintain their original references (not made</span><span> </span><span>observable)</span></li></span></ul></span><span><h3 id="_3-using-observableref-annotation"><span>3. Using </span><span><code>observable.ref</code></span><span> annotation</span></h3></span><span><pre class="language-ts"><code>// With observable()
observable(obj, { prop: &quot;observable.ref&quot; })

// Or with makeObservable()
makeObservable(obj, { prop: &quot;observable.ref&quot; })
</code></pre></span><span><p><span>This implementation:</span></p></span><span><ul><span><li><span>Makes the property observable</span></li></span><span><li><span>Maintains the original references for property values (like</span><span> </span><span><code>{ shallowRef: true }</code></span><span>)</span></li></span><span><li><span>For collections (Arrays, Maps, Sets), it behaves like </span><span><code>{ shallowRef: true }</code></span><span> </span><span>option:</span><span><ul><span><li><span>The collection is NOT converted to an</span><span> </span><span>ObservableArray/ObservableMap/ObservableSet</span></li></span><span><li><span>Changes to the collection (adding/removing items) will NOT trigger reactions</span></li></span><span><li><span>Only replacing the entire collection will trigger reactions</span></li></span></ul></span></li></span></ul></span><span><h2 id="why-three-different-implementations"><span>Why Three Different Implementations?</span></h2></span><span><h3 id="react-props-use-case"><span>React Props Use Case</span></h3></span><span><p><span>The </span><span><code>observable({}, {}, { shallowRef: true })</code></span><span> implementation and</span><span> </span><span><code>observable.ref</code></span><span> annotation were created specifically to handle React props. In</span><span> </span><span>React components, we want to:</span></p></span><span><ol><span><li><span>Observe when props change</span></li></span><span><li><span>Maintain the original object references for each prop value to preserve</span><span> </span><span>identity and prevent unnecessary renders</span></li></span><span><li><span>Avoid making the props' values themselves observable, as they come from</span><span> </span><span>parent components and shouldn't be mutated</span></li></span></ol></span><span><p><span>Making collections like arrays non-observable is important in this case because</span><span> </span><span>we want to preserve reference equality and avoid adding reactivity to data that</span><span> </span><span>should be treated as immutable in React.</span></p></span><span><h3 id="collection-level-reactivity"><span>Collection-Level Reactivity</span></h3></span><span><p><span>The </span><span><code>observable.shallow</code></span><span> annotation approach is useful when:</span></p></span><span><ol><span><li><span>You want to track changes to collections (additions, deletions)</span></li></span><span><li><span>But don't want to make the items within those collections observable</span></li></span><span><li><span>This provides a good balance between reactivity and performance</span></li></span></ol></span><span><p><span>This is particularly useful for collections where you care about their</span><span> </span><span>composition changing, but the items themselves might be complex objects that you</span><span> </span><span>don't want to make deeply observable.</span></p></span><span><h2 id="implementation-details"><span>Implementation Details</span></h2></span><span><p><span>In the codebase:</span></p></span><span><ol><span><li><span><p><span>For </span><span><code>observable({}, {}, { shallowRef: true })</code></span><span>:</span></p></span><span><ul><span><li><span>Implementation uses </span><span><code>observableBox(value, equalityOptions)</code></span><span> for all values</span></li></span><span><li><span>Values are wrapped directly in an observable box without transformation</span></li></span></ul></span></li></span><span><li><span><p><span>For </span><span><code>observable.shallow</code></span><span> annotation (both with </span><span><code>observable()</code></span><span> and</span><span> </span><span><code>makeObservable()</code></span><span>):</span></p></span><span><ul><span><li><span>Collections are first converted to their observable variants with</span><span> </span><span><code>{ shallow: true }</code></span></li></span><span><li><span>Then these observable collections are wrapped in an observable box</span></li></span><span><li><span>This preserves collection-specific reactivity while keeping collection</span><span> </span><span>items non-observable</span></li></span></ul></span></li></span><span><li><span><p><span>For </span><span><code>observable.ref</code></span><span> annotation:</span></p></span><span><ul><span><li><span>Implementation is similar to </span><span><code>{ shallowRef: true }</code></span><span> option but applied as</span><span> </span><span>an annotation</span></li></span><span><li><span>Creates a direct observable box for the value without transforming it</span></li></span><span><li><span>Maintains original references of the property values</span></li></span></ul></span></li></span></ol></span><span><h2 id="when-to-use-which"><span>When To Use Which</span></h2></span><span><ul><span><li><span><p><span>Use </span><span><code>observable({}, {}, { shallowRef: true })</code></span><span> when:</span></p></span><span><ul><span><li><span>Working with React props in a global manner</span></li></span><span><li><span>Need to maintain reference equality for all properties</span></li></span><span><li><span>Don't want collection operations to trigger reactions</span></li></span></ul></span></li></span><span><li><span><p><span>Use </span><span><code>observable.ref</code></span><span> annotation when:</span></p></span><span><ul><span><li><span>Working with specific React props or immutable values</span></li></span><span><li><span>Need to maintain reference equality for specific properties</span></li></span><span><li><span>Don't want collection operations to trigger reactions</span></li></span><span><li><span>Need property-level control rather than object-level control</span></li></span></ul></span></li></span><span><li><span><p><span>Use </span><span><code>observable.shallow</code></span><span> annotation when:</span></p></span><span><ul><span><li><span>You want collection operations (add/delete) to trigger reactions</span></li></span><span><li><span>But don't want the items in the collections to become observable</span></li></span><span><li><span>Working with class instances or objects with collections that need specific</span><span> </span><span>observable behavior</span></li></span></ul></span></li></span></ul></span></div></div></article></div></main><aside class="docs-toc"><h3 class="toc-title">On this page</h3><nav><ul class="toc-nav"><li><a href="#the-three-implementations" data-level="2" class="toc-link ">The Three Implementations</a><ul class="toc-nav"><li><a href="#_1-using-observable-with-shallowref-true-option" data-level="3" class="toc-link ">1. Using observable() with { shallowRef: true } option</a></li><li><a href="#_2-using-observableshallow-annotation" data-level="3" class="toc-link ">2. Using observable.shallow annotation</a></li><li><a href="#_3-using-observableref-annotation" data-level="3" class="toc-link ">3. Using observable.ref annotation</a></li></ul></li><li><a href="#why-three-different-implementations" data-level="2" class="toc-link ">Why Three Different Implementations?</a><ul class="toc-nav"><li><a href="#react-props-use-case" data-level="3" class="toc-link ">React Props Use Case</a></li><li><a href="#collection-level-reactivity" data-level="3" class="toc-link ">Collection-Level Reactivity</a></li></ul></li><li><a href="#implementation-details" data-level="2" class="toc-link ">Implementation Details</a></li><li><a href="#when-to-use-which" data-level="2" class="toc-link ">When To Use Which</a></li></ul></nav></aside></div></div></body></html>